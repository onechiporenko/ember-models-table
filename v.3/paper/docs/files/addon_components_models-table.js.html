<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/components/models-table.js - ember-models-table</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="ember-models-table" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 3.0.0-beta.3.b7ad286e</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Components.Bs4ModelsTableColumnsDropdown.html">Components.Bs4ModelsTableColumnsDropdown</a></li>
                                <li><a href="../classes/Components.Bs4ModelsTableDataGroupBySelect.html">Components.Bs4ModelsTableDataGroupBySelect</a></li>
                                <li><a href="../classes/Components.Bs4ModelsTableGlobalFilter.html">Components.Bs4ModelsTableGlobalFilter</a></li>
                                <li><a href="../classes/Components.Bs4ModelsTableRowFilteringCell.html">Components.Bs4ModelsTableRowFilteringCell</a></li>
                                <li><a href="../classes/Components.Ebs3ModelsTableColumnsDropdown.html">Components.Ebs3ModelsTableColumnsDropdown</a></li>
                                <li><a href="../classes/Components.Ebs3ModelsTableDataGroupBySelect.html">Components.Ebs3ModelsTableDataGroupBySelect</a></li>
                                <li><a href="../classes/Components.Ebs3ModelsTableGlobalFilter.html">Components.Ebs3ModelsTableGlobalFilter</a></li>
                                <li><a href="../classes/Components.Ebs3ModelsTableRowFilteringCell.html">Components.Ebs3ModelsTableRowFilteringCell</a></li>
                                <li><a href="../classes/Components.Ebs3ModelsTableSummary.html">Components.Ebs3ModelsTableSummary</a></li>
                                <li><a href="../classes/Components.Ebs4ModelsTableColumnsDropdown.html">Components.Ebs4ModelsTableColumnsDropdown</a></li>
                                <li><a href="../classes/Components.Ebs4ModelsTableDataGroupBySelect.html">Components.Ebs4ModelsTableDataGroupBySelect</a></li>
                                <li><a href="../classes/Components.Ebs4ModelsTableGlobalFilter.html">Components.Ebs4ModelsTableGlobalFilter</a></li>
                                <li><a href="../classes/Components.Ebs4ModelsTableRowFilteringCell.html">Components.Ebs4ModelsTableRowFilteringCell</a></li>
                                <li><a href="../classes/Components.Ebs4ModelsTableSummary.html">Components.Ebs4ModelsTableSummary</a></li>
                                <li><a href="../classes/Components.EpModelsTableCellContentEdit.html">Components.EpModelsTableCellContentEdit</a></li>
                                <li><a href="../classes/Components.EpModelsTableColumnsDropdown.html">Components.EpModelsTableColumnsDropdown</a></li>
                                <li><a href="../classes/Components.EpModelsTableDataGroupBySelect.html">Components.EpModelsTableDataGroupBySelect</a></li>
                                <li><a href="../classes/Components.EpModelsTableExpandAllToggle.html">Components.EpModelsTableExpandAllToggle</a></li>
                                <li><a href="../classes/Components.EpModelsTableExpandToggle.html">Components.EpModelsTableExpandToggle</a></li>
                                <li><a href="../classes/Components.EpModelsTableGlobalFilter.html">Components.EpModelsTableGlobalFilter</a></li>
                                <li><a href="../classes/Components.EpModelsTablePageSizeSelect.html">Components.EpModelsTablePageSizeSelect</a></li>
                                <li><a href="../classes/Components.EpModelsTablePaginationNumeric.html">Components.EpModelsTablePaginationNumeric</a></li>
                                <li><a href="../classes/Components.EpModelsTablePaginationSimple.html">Components.EpModelsTablePaginationSimple</a></li>
                                <li><a href="../classes/Components.EpModelsTableRowFilteringCell.html">Components.EpModelsTableRowFilteringCell</a></li>
                                <li><a href="../classes/Components.EpModelsTableRowSelectAllCheckbox.html">Components.EpModelsTableRowSelectAllCheckbox</a></li>
                                <li><a href="../classes/Components.EpModelsTableRowSelectCheckbox.html">Components.EpModelsTableRowSelectCheckbox</a></li>
                                <li><a href="../classes/Components.EpModelsTableRowSortingCell.html">Components.EpModelsTableRowSortingCell</a></li>
                                <li><a href="../classes/Components.EpModelsTableSelect.html">Components.EpModelsTableSelect</a></li>
                                <li><a href="../classes/Components.EpModelsTableSummary.html">Components.EpModelsTableSummary</a></li>
                                <li><a href="../classes/Components.EsuiModelsTableRowFilteringCell.html">Components.EsuiModelsTableRowFilteringCell</a></li>
                                <li><a href="../classes/Components.EsuiModelsTableSelect.html">Components.EsuiModelsTableSelect</a></li>
                                <li><a href="../classes/Components.ModelsTable.html">Components.ModelsTable</a></li>
                                <li><a href="../classes/Components.ModelsTableCell.html">Components.ModelsTableCell</a></li>
                                <li><a href="../classes/Components.ModelsTableCellColumnSummary.html">Components.ModelsTableCellColumnSummary</a></li>
                                <li><a href="../classes/Components.ModelsTableCellContentDisplay.html">Components.ModelsTableCellContentDisplay</a></li>
                                <li><a href="../classes/Components.ModelsTableCellContentEdit.html">Components.ModelsTableCellContentEdit</a></li>
                                <li><a href="../classes/Components.ModelsTableCellEditToggle.html">Components.ModelsTableCellEditToggle</a></li>
                                <li><a href="../classes/Components.ModelsTableColumnsDropdown.html">Components.ModelsTableColumnsDropdown</a></li>
                                <li><a href="../classes/Components.ModelsTableColumnsHidden.html">Components.ModelsTableColumnsHidden</a></li>
                                <li><a href="../classes/Components.ModelsTableDataGroupBySelect.html">Components.ModelsTableDataGroupBySelect</a></li>
                                <li><a href="../classes/Components.ModelsTableExpandAllToggle.html">Components.ModelsTableExpandAllToggle</a></li>
                                <li><a href="../classes/Components.ModelsTableExpandToggle.html">Components.ModelsTableExpandToggle</a></li>
                                <li><a href="../classes/Components.ModelsTableFooter.html">Components.ModelsTableFooter</a></li>
                                <li><a href="../classes/Components.ModelsTableGlobalFilter.html">Components.ModelsTableGlobalFilter</a></li>
                                <li><a href="../classes/Components.ModelsTableGroupedHeader.html">Components.ModelsTableGroupedHeader</a></li>
                                <li><a href="../classes/Components.ModelsTableGroupSummaryRow.html">Components.ModelsTableGroupSummaryRow</a></li>
                                <li><a href="../classes/Components.ModelsTableNoData.html">Components.ModelsTableNoData</a></li>
                                <li><a href="../classes/Components.ModelsTablePageSizeSelect.html">Components.ModelsTablePageSizeSelect</a></li>
                                <li><a href="../classes/Components.ModelsTablePaginationNumeric.html">Components.ModelsTablePaginationNumeric</a></li>
                                <li><a href="../classes/Components.ModelsTablePaginationSimple.html">Components.ModelsTablePaginationSimple</a></li>
                                <li><a href="../classes/Components.ModelsTableRow.html">Components.ModelsTableRow</a></li>
                                <li><a href="../classes/Components.ModelsTableRowExpand.html">Components.ModelsTableRowExpand</a></li>
                                <li><a href="../classes/Components.ModelsTableRowFiltering.html">Components.ModelsTableRowFiltering</a></li>
                                <li><a href="../classes/Components.ModelsTableRowFilteringCell.html">Components.ModelsTableRowFilteringCell</a></li>
                                <li><a href="../classes/Components.ModelsTableRowGrouping.html">Components.ModelsTableRowGrouping</a></li>
                                <li><a href="../classes/Components.ModelsTableRowGroupToggle.html">Components.ModelsTableRowGroupToggle</a></li>
                                <li><a href="../classes/Components.ModelsTableRowSelectAllCheckbox.html">Components.ModelsTableRowSelectAllCheckbox</a></li>
                                <li><a href="../classes/Components.ModelsTableRowSelectCheckbox.html">Components.ModelsTableRowSelectCheckbox</a></li>
                                <li><a href="../classes/Components.ModelsTableRowSorting.html">Components.ModelsTableRowSorting</a></li>
                                <li><a href="../classes/Components.ModelsTableRowSortingCell.html">Components.ModelsTableRowSortingCell</a></li>
                                <li><a href="../classes/Components.ModelsTableSelect.html">Components.ModelsTableSelect</a></li>
                                <li><a href="../classes/Components.ModelsTableServerPaginated.html">Components.ModelsTableServerPaginated</a></li>
                                <li><a href="../classes/Components.ModelsTableSummary.html">Components.ModelsTableSummary</a></li>
                                <li><a href="../classes/Components.ModelsTableTable.html">Components.ModelsTableTable</a></li>
                                <li><a href="../classes/Components.ModelsTableTableBody.html">Components.ModelsTableTableBody</a></li>
                                <li><a href="../classes/Components.ModelsTableTableFooter.html">Components.ModelsTableTableFooter</a></li>
                                <li><a href="../classes/Components.ModelsTableTableHeader.html">Components.ModelsTableTableHeader</a></li>
                                <li><a href="../classes/Components.SuiModelsTableCellContentEdit.html">Components.SuiModelsTableCellContentEdit</a></li>
                                <li><a href="../classes/Components.SuiModelsTableColumnsDropdown.html">Components.SuiModelsTableColumnsDropdown</a></li>
                                <li><a href="../classes/Components.SuiModelsTableDataGroupBySelect.html">Components.SuiModelsTableDataGroupBySelect</a></li>
                                <li><a href="../classes/Components.SuiModelsTableExpandAllToggle.html">Components.SuiModelsTableExpandAllToggle</a></li>
                                <li><a href="../classes/Components.SuiModelsTableExpandToggle.html">Components.SuiModelsTableExpandToggle</a></li>
                                <li><a href="../classes/Components.SuiModelsTableGlobalFilter.html">Components.SuiModelsTableGlobalFilter</a></li>
                                <li><a href="../classes/Components.SuiModelsTablePaginationNumeric.html">Components.SuiModelsTablePaginationNumeric</a></li>
                                <li><a href="../classes/Components.SuiModelsTablePaginationSimple.html">Components.SuiModelsTablePaginationSimple</a></li>
                                <li><a href="../classes/Components.SuiModelsTableRowFilteringCell.html">Components.SuiModelsTableRowFilteringCell</a></li>
                                <li><a href="../classes/Components.SuiModelsTableRowSelectAllCheckbox.html">Components.SuiModelsTableRowSelectAllCheckbox</a></li>
                                <li><a href="../classes/Components.SuiModelsTableRowSelectCheckbox.html">Components.SuiModelsTableRowSelectCheckbox</a></li>
                                <li><a href="../classes/Components.SuiModelsTableSelect.html">Components.SuiModelsTableSelect</a></li>
                                <li><a href="../classes/Components.SuiModelsTableSummary.html">Components.SuiModelsTableSummary</a></li>
                                <li><a href="../classes/Internal.ColumnDropdownOptions.html">Internal.ColumnDropdownOptions</a></li>
                                <li><a href="../classes/Internal.ColumnSet.html">Internal.ColumnSet</a></li>
                                <li><a href="../classes/Internal.GroupedHeader.html">Internal.GroupedHeader</a></li>
                                <li><a href="../classes/Internal.SelectOption.html">Internal.SelectOption</a></li>
                                <li><a href="../classes/Internal.SortMap.html">Internal.SortMap</a></li>
                                <li><a href="../classes/Themes.Bootstrap3Theme.html">Themes.Bootstrap3Theme</a></li>
                                <li><a href="../classes/Themes.Bootstrap4Theme.html">Themes.Bootstrap4Theme</a></li>
                                <li><a href="../classes/Themes.DefaultTheme.html">Themes.DefaultTheme</a></li>
                                <li><a href="../classes/Themes.EmberBootstrap3Theme.html">Themes.EmberBootstrap3Theme</a></li>
                                <li><a href="../classes/Themes.EmberBootstrap4Theme.html">Themes.EmberBootstrap4Theme</a></li>
                                <li><a href="../classes/Themes.EmberPaperTheme.html">Themes.EmberPaperTheme</a></li>
                                <li><a href="../classes/Themes.EmberSemanticUITheme.html">Themes.EmberSemanticUITheme</a></li>
                                <li><a href="../classes/Themes.SemanticUITheme.html">Themes.SemanticUITheme</a></li>
                                <li><a href="../classes/Utils.ModelsTableColumn.html">Utils.ModelsTableColumn</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: addon/components/models-table.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import {assign} from &#x27;@ember/polyfills&#x27;;
import {typeOf, compare, isBlank, isNone, isPresent} from &#x27;@ember/utils&#x27;;
import {run} from &#x27;@ember/runloop&#x27;;
import Component from &#x27;@ember/component&#x27;;
import {assert, warn} from &#x27;@ember/debug&#x27;;
import EmberObject, {
  action,
  computed,
  getProperties,
  setProperties,
  set,
  get
} from &#x27;@ember/object&#x27;;
import {classNames, layout as templateLayout} from &#x27;@ember-decorators/component&#x27;;
import {observes} from &#x27;@ember-decorators/object&#x27;;
import {alias, filterBy, notEmpty} from &#x27;@ember/object/computed&#x27;;
import {isArray, A} from &#x27;@ember/array&#x27;;
import betterCompare from &#x27;../utils/better-compare&#x27;;
import layout from &#x27;../templates/components/models-table&#x27;;
import ModelsTableColumn, {propertyNameToTitle} from &#x27;../utils/column&#x27;;

/**
 * @class GroupedHeader
 * @namespace Internal
 */
/**
 * Header for grouped columns
 * @property title
 * @type string
 * @for GroupedHeader
 */
/**
 * HTML colspan attr
 * @property colspan
 * @type number
 * @for GroupedHeader
 */
/**
 * HTML rowspan attr
 * @property rowspan
 * @type number
 * @for GroupedHeader
 */

/**
 * @class SelectOption
 * @namespace Internal
 */
/**
 * @property value
 * @for SelectOption
 * @type {string|number|boolean}
 */
/**
 * @property label
 * @for SelectOption
 * @type {string|number|boolean}
 */

/**
 * @class ColumnSet
 * @namespace Internal
 */
/**
 * @property label
 * @for ColumnSet
 * @type string
 */
/**
 * @property showColumns
 * @for ColumnSet
 * @type string[]|Function
 */
/**
 * @property hideOtherColumns
 * @for ColumnSet
 * @type boolean
 */
/**
 * @property toggleSet
 * @for ColumnSet
 * @type boolean
 */

/**
 * @class ColumnDropdownOptions
 * @namespace Internal
 */
/**
 * @property showAll
 * @type boolean
 * @for ColumnDropdownOptions
 */
/**
 * @property hideAll
 * @type boolean
 * @for ColumnDropdownOptions
 */
/**
 * @property restoreDefaults
 * @type boolean
 * @for ColumnDropdownOptions
 */
/**
 * @property columnSets
 * @type ColumnSet[]
 * @for ColumnDropdownOptions
 */

/**
 * @class SortMap
 * @namespace Internal
 */
/**
 * @property asc
 * @type string
 * @for SortMap
 */
/**
 * @property desc
 * @type string
 * @for SortMap
 */
/**
 * @property none
 * @type string
 * @for SortMap
 */

const {
  keys,
  prototype: {
    hasOwnProperty
  }
} = Object;

const NOT_SORTED = -1;

/*
 * @param {Utils.ModelsTableColumn} column
 * @return boolean
 */
function isSortedByDefault(column) {
  return column.sortPrecedence &gt; NOT_SORTED;
}

/*
 * Default filter-function used in the filter by columns
 *
 * @param {string} cellValue value in the table cell
 * @param {string} filterString needed substring
 * @return boolean
 */
function defaultFilter(cellValue, filterString) {
  return -1 !== cellValue.indexOf(filterString);
}

/*
 * @param {string} option
 * @return {{value: string|number|boolean, label: string|number|boolean}}
 */
function optionStrToObj(option) {
  return {value: option, label: option};
}

/*
 * Updates &#x60;filterOptions&#x60; for column which use &#x60;filterWithSelect&#x60;
 * and don&#x27;t have &#x60;predefinedFilterOptions&#x60;
 * &#x60;filterOptions&#x60; are calculated like &#x60;data.mapBy(column.propertyName).uniq()&#x60;,
 * where data is component&#x27;s &#x60;data&#x60;
 *
 * @param {string} propertyName
 * @return {object[]}
 */
function getFilterOptionsCP(propertyName) {
  return computed(&#x60;data.@each.${propertyName}&#x60;, function () {
    if (this.filterWithSelect &amp;&amp; &#x27;array&#x27; !== typeOf(this.predefinedFilterOptions)) {
      let _data = A(A(this.data).compact());
      let options = A(_data.mapBy(propertyName)).compact();
      if (this.sortFilterOptions) {
        options = options.sort();
      }
      return A(A([&#x27;&#x27;, ...options]).uniq().map(optionStrToObj));
    }
    return [];
  });
}

function chunkBy(collection, propertyName, sortOrder) {
  const doSort = arguments.length === 3;
  const chunks = A([]);
  const values = [];
  if (!isArray(collection)) {
    return chunks;
  }
  collection.forEach(item =&gt; {
    const value = get(item, propertyName);
    if (values.indexOf(value) === -1) {
      values.push(value);
      chunks.push(A([]));
    }
    const index = values.indexOf(value);
    chunks[index].pushObject(item);
  });
  if (doSort) {
    const sortedValues = values.slice().sort((v1, v2) =&gt; {
      let result = betterCompare(v1, v2);
      if (result !== 0) {
        return (sortOrder === &#x27;desc&#x27;) ? (-1 * result) : result;
      }
      return 0;
    });
    return sortedValues.map(v =&gt; chunks[values.indexOf(v)]);
  }
  return chunks;
}

function objToArray(map) {
  let ret = [];
  if (isArray(map)) {
    map.forEach(m =&gt; {
      ret = [...ret, ...m];
    });
    return ret;
  }
  keys(map).forEach(k =&gt; {
    if (isArray(map[k])) {
      ret = [...ret, ...map[k]];
    }
  });
  return ret;
}

/**
 * Table-component with pagination, sorting and filtering.
 *
 * It should be used when whole dataset is already loaded. For server-side pagination, filtering and sorting
 * [models-table-server-paginated](Components.ModelsTableServerPaginated.html) should be used.
 *
 * Basic usage example:
 *
 * &#x60;&#x60;&#x60;hbs
 * &lt;ModelsTable @data={{model}} @columns={{columns}} /&gt;
 * &#x60;&#x60;&#x60;
 *
 * Usage with block context:
 *
 * &#x60;&#x60;&#x60;hbs
 * &lt;ModelsTable @data={{data}} @columns={{columns}} as |MT|&gt;
 *   &lt;MT.GlobalFilter /&gt;
 *   &lt;MT.DataGroupBySelect /&gt;
 *   &lt;MT.ColumnsDropdown /&gt;
 *   &lt;MT.Table /&gt;
 *   &lt;MT.Footer /&gt;
 * &lt;/ModelsTable&gt;
 * &#x60;&#x60;&#x60;
 *
 * ModelsTable yields references to the following contextual components:
 *
 * * [models-table/global-filter](Components.ModelsTableGlobalFilter.html) - global filter used for table data
 * * [models-table/columns-dropdown](Components.Utils.ModelsTableColumnsDropdown.html) - dropdown with list of options to toggle columns and column-sets visibility
 * * [models-table/data-group-by-select](Components.ModelsTableDataGroupBySelect.html) - dropdown to select property for table-rows grouping
 * * [models-table/table](Components.ModelsTableTable.html) - table with a data
 * * [models-table/footer](Components.ModelsTableFooter.html) - summary and pagination
 *
 * Check own docs for each component to get detailed info.
 *
 * ModelsTable has a lot of options you may configure, but there are two required properties called &#x60;data&#x60; and &#x60;columns&#x60;. First one contains data (e.g. list of records from the store). Second one is a list of table&#x27;s columns (check [models-table-column](Utils.ModelsTableColumn.html) for available options).
 *
 * @class ModelsTable
 * @namespace Components
 * @extends Ember.Component
 */
export default
@templateLayout(layout)
@classNames(&#x27;models-table-wrapper&#x27;)
class ModelsTableComponent extends Component {
  /**
   * Number of records shown on one table-page
   *
   * @property pageSize
   * @type number
   * @default 10
   */
  pageSize = 10;

  /**
   * Currently shown page number. It may be set initially
   *
   * @property currentPageNumber
   * @type number
   * @default 1
   */
  currentPageNumber = 1;

  /**
   * Order of sorting for each columns. Unsorted column firstly become sorted ASC, then DESC, then sorting is dropped again
   *
   * @property sortMap
   * @type Internal.SortMap
   */
  sortMap = {
    none: &#x27;asc&#x27;,
    asc: &#x27;desc&#x27;,
    desc: &#x27;none&#x27;
  };

  /**
   * List of properties to sort table rows
   *
   * Each value is like &#x27;propertyName:sortDirection&#x27;
   *
   * @property sortProperties
   * @protected
   */
  sortProperties = A([]);

  /**
   * Hash of custom functions to sort table rows
   *
   * @property sortFunctions
   * @type object
   * @protected
   */
  sortFunctions = Object.create(null);

  /**
   * @property forceToFirstPageProps
   * @type string[]
   * @protected
   * @default [&#x27;processedColumns.@each.filterString&#x27;, &#x27;filterString&#x27;, &#x27;pageSize&#x27;]
   */
  forceToFirstPageProps = A([&#x27;processedColumns.@each.filterString&#x27;, &#x27;filterString&#x27;, &#x27;pageSize&#x27;]);

  /**
   * Determines if multi-columns sorting should be used
   *
   * @property multipleColumnsSorting
   * @type boolean
   * @default true
   */
  multipleColumnsSorting = true;

  /**
   * Determines if component footer should be shown on the page
   *
   * @property showComponentFooter
   * @type boolean
   * @default true
   */
  showComponentFooter = true;

  /**
   * Determines if dropdown for current page number should be shown near the pagination block
   *
   * @property showCurrentPageNumberSelect
   * @type boolean
   * @default true
   */
  showCurrentPageNumberSelect = true;

  /**
   * Determines if numeric pagination should be used
   *
   * @property useNumericPagination
   * @type boolean
   * @default false
   */
  useNumericPagination = false;

  /**
   * Determines if columns-dropdown should be shown
   *
   * @property showColumnsDropdown
   * @type boolean
   * @default true
   */
  showColumnsDropdown = true;

  /**
   * Determines if filtering by columns should be available to the user
   *
   * @property useFilteringByColumns
   * @type boolean
   * @default true
   */
  useFilteringByColumns = true;

  /**
   * Global filter value
   *
   * @property filterString
   * @type string
   * @default &#x27;&#x27;
   */
  filterString = &#x27;&#x27;;

  /**
   * Determines if filtering (global and by column) should ignore case
   *
   * @property filteringIgnoreCase
   * @type boolean
   * @default false
   */
  filteringIgnoreCase = false;

  /**
   * Determines if filtering should be done by hidden columns
   *
   * **Notice:** after changing this value filtering results will be updated only after filter options are changed
   *
   * @property doFilteringByHiddenColumns
   * @type boolean
   * @default true
   */
  doFilteringByHiddenColumns = true;

  /**
   * Determines if &#x27;Global filter&#x27;-field should be shown
   *
   * @property showGlobalFilter
   * @type boolean
   * @default true
   */
  showGlobalFilter = true;

  /**
   * Determines if focus should be on the &#x27;Global filter&#x27;-field on component render
   *
   * @property focusGlobalFilter
   * @type boolean
   * @default false
   */
  focusGlobalFilter = false;

  /**
   * Value for development purposes. Used to check translation issues like:
   *
   * * Auto generated titles for columns
   *
   * @property checkTextTranslations
   * @type boolean
   * @default false
   */
  checkTextTranslations = false;

  /**
   * Determines if &#x60;processedColumns&#x60; will be updated if &#x60;columns&#x60; are changed (&#x60;propertyName&#x60; and &#x60;template&#x60; are observed)
   *
   * **IMPORTANT** All filter, sort and visibility options will be dropped to the default values while updating
   *
   * @property columnsAreUpdateable
   * @type boolean
   * @default false
   */
  columnsAreUpdateable = false;

  /**
   * Determines if rows should be grouped for some property
   *
   * Grouped value may be shown in the separated row on the top of the group or in the first column (in the cell with rowspan) in the each group (see [displayGroupedValueAs](Components.ModelsTable.html#property_displayGroupedValueAs))
   *
   * Generally you should not show column with property which is used for grouping (but it&#x27;s up to you)
   *
   * @property useDataGrouping
   * @type boolean
   * @default false
   */
  useDataGrouping = false;

  /**
   * Property name used now for grouping rows
   *
   * **IMPORTANT** It should be set initially if [useDataGrouping](Components.ModelsTable.html#property_useDataGrouping) is set to &#x60;true&#x60;
   *
   * @property currentGroupingPropertyName
   * @type string
   * @default null
   */
  currentGroupingPropertyName = null;

  /**
   * Sort direction for grouped property values
   *
   * @property sortByGroupedFieldDirection
   * @protected
   * @type string
   * @default &#x27;asc&#x27;
   */
  sortByGroupedFieldDirection = &#x27;asc&#x27;;

  /**
   * Determines how grouped value will be displayed - as a row or column
   *
   * Allowed values are &#x60;row&#x60; and &#x60;column&#x60;
   *
   * @property displayGroupedValueAs
   * @type string
   * @default &#x27;row&#x27;
   */
  displayGroupedValueAs = &#x27;row&#x27;;

  /**
   * Used in numeric pagination. If pages count is less than &#x60;collapseNumPaginationForPagesCount&#x60;, all pages will be shown.
   * E.g. for &#x60;collapseNumPaginationForPagesCount = 4&#x60; and &#x60;pagesCount = 4&#x60; pagination will be &#x60;1 2 3 4&#x60;, however for
   * &#x60;collapseNumPaginationForPagesCount = 1&#x60; and &#x60;pagesCount = 4&#x60; pagination will be &#x60;1 2 ... 4&#x60;
   *
   * @property collapseNumPaginationForPagesCount
   * @type number
   * @default 1
   */
  collapseNumPaginationForPagesCount = 1;

  /**
   * &#x60;columns&#x60; fields which are observed to update shown table-columns
   * It is used only if &#x60;columnsAreUpdateable&#x60; is &#x60;true&#x60;
   *
   * @property columnFieldsToCheckUpdate
   * @type string[]
   * @default [&#x27;propertyName&#x27;, &#x27;component&#x27;]
   */
  columnFieldsToCheckUpdate = A([&#x27;propertyName&#x27;, &#x27;component&#x27;]);

  /**
   * &#x60;themeInstance&#x60; is an instance of [DefaultTheme](Themes.Default.html) or it&#x27;s children.
   * By default &#x60;models-table&#x60; uses [BootstrapTheme](Themes.Bootstrap3.html) instance.
   *
   * You may create your own theme-class and set &#x60;themeInstance&#x60; to it&#x27;s instance. Check Theme properties you may define in your own theme.
   *
   * @type Themes.Bootstrap3Theme
   * @property ThemeInstance
   */

  /**
   * All table records
   *
   * It&#x27;s a first of the two attributes you must set to the component
   *
   * @property data
   * @type object[]
   * @default []
   */
  data = A([]);

  /**
   * Table columns. Check [ModelsTableColumn](Utils.ModelsTableColumn.html) for available properties
   *
   * It&#x27;s a second of the two attributes you must set to the component
   *
   * @property columns
   * @type Utils.ModelsTableColumn[]
   * @default []
   */
  columns = A([]);

  /**
   * Hash of components to be used for columns.
   *
   * See [ModelsTableColumn](Utils.ModelsTableColumn.html), property component
   *
   * @property columnComponents
   * @type object
   * @default {}
   */
  columnComponents = {};

  /**
   * Sets of columns that can be toggled together.
   * Each object should have:
   *  * &#x60;label&#x60; (string) - The label for the set. This will be displayed in the columns dropdown.
   *  * &#x60;showColumns&#x60; (array|Function) - This should either be an array of &#x60;propertyNames&#x60; to show, or a function. If it is a function, the function will be called with the &#x60;processedColumns&#x60; as attribute.
   *  * &#x60;hideOtherColumns&#x60; (boolean) -  If this is true (default), all columns not specified in &#x60;showColumns&#x60; will be hidden. If this is set to false, other columns will be left at whatever visibility they were before.
   *  * &#x60;toggleSet&#x60; (boolean) - If this is true (default is false), the set columns will be shown if one of them is currently hidden,
   else they will all be hidden. Settings this will result in a default of &#x60;hideOtherColumns=false&#x60;
   *
   * @property columnSets
   * @type Internal.ColumnSet[]
   * @default []
   */
  columnSets = A([]);

  /**
   * List of columns shown in the table. It&#x27;s created from the [columns](Components.ModelsTable.html#property_columns) provided to the component
   *
   * @protected
   * @property processedColumns
   * @type Utils.ModelsTableColumn[]
   * @default []
   */
  processedColumns = A([]);

  /**
   * List of the additional headers. Used to group columns.
   *
   * Each object may have such fields:
   *
   * * &#x60;title&#x60; (string) - Header for grouped column
   * * &#x60;colspan&#x60; (number) - HTML colspan attr
   * * &#x60;rowspan&#x60; (number) - HTML rowspan attr
   *
   * @property groupedHeaders
   * @type Internal.GroupedHeader[][]
   * @default []
   */
  groupedHeaders = A([]);

  /**
   * Determines if page size should be shown
   *
   * @property showPageSize
   * @type boolean
   * @default true
   */
  showPageSize = true;

  /**
   * Expanded row items.
   *
   * It&#x27;s set to the initial value when current page or page size is changed
   *
   * @property  expandedItems
   * @type object[]
   * @default []
   */
  @computed()
  get expandedItems() {
    return A([]);
  }
  set expandedItems(v) {
    return A(v);
  }

  /**
   * true - allow to expand more than 1 row,
   * false - only 1 row may be expanded in the same time
   *
   * @property multipleExpand
   * @type boolean
   * @default false
   */
  multipleExpand = false;

  /**
   * List of grouped property values where the groups are collapsed
   *
   * @property collapsedGroupValues
   * @type array[]
   * @default []
   */
  @computed()
  get collapsedGroupValues() {
    return A([]);
  }
  set collapsedGroupValues(v) {
    return A(v);
  }

  /**
   * Allow or disallow to select rows on click.
   * If &#x60;false&#x60; - no row can be selected
   *
   * @property selectRowOnClick
   * @type boolean
   * @default true
   */
  selectRowOnClick = true;

  /**
   * Allow or disallow to select multiple rows.
   * If &#x60;false&#x60; - only one row may be selected in the same time
   *
   * @property multipleSelect
   * @type boolean
   * @default false
   */
  multipleSelect = false;

  /**
   * Component used in the &#x27;expanded&#x27; row
   *
   * It will receive several options:
   * * &#x60;record&#x60; - current row value
   * * &#x60;processedColumns&#x60; - current column (one of the [processedColumns](Components.ModelsTable.html#property_processedColumns))
   * * &#x60;index&#x60; - current row index
   * * &#x60;selectedItems&#x60; - bound from [selectedItems](Components.ModelsTable.html#property_selectedItems)
   * * &#x60;visibleProcessedColumns&#x60; - bound from [visibleProcessedColumns](Components.ModelsTable.html#property_visibleProcessedColumns)
   * * &#x60;clickOnRow&#x60; - closure action [clickOnRow](Components.ModelsTable.html#event_clickOnRow)
   * * &#x60;themeInstance&#x60; - bound from [themeInstance](Components.ModelsTable.html#property_themeInstance)
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @expandedRowComponent={{component &quot;expanded-row&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @property expandedRowComponent
   * @type object
   * @default null
   */
  expandedRowComponent = null;

  /**
   * Component used in the row with a grouped value
   *
   * This component won&#x27;t be used if [useDataGrouping](Components.ModelsTable.html#property_useDataGrouping) is not &#x60;true&#x60;
   *
   * Component will receive several options:
   *
   * * &#x60;groupedValue&#x60; - grouped property value
   * * &#x60;currentGroupingPropertyName&#x60; - bound from [currentGroupingPropertyName](Components.ModelsTable.html#property_currentGroupingPropertyName)
   * * &#x60;displayGroupedValueAs&#x60; - bound from [displayGroupedValueAs](Components.ModelsTable.html#property_displayGroupedValueAs)
   * * &#x60;toggleGroupedRows&#x60; - closure action [toggleGroupedRows](Components.ModelsTable.html#event_toggleGroupedRows)
   * * &#x60;toggleGroupedRowsExpands&#x60; - closure action [toggleGroupedRowsExpands](Components.ModelsTable.html#event_toggleGroupedRowsExpands)
   * * &#x60;toggleGroupedRowsSelection&#x60; - closure action [toggleGroupedRowsSelection](Components.ModelsTable.html#event_toggleGroupedRowsSelection)
   * * &#x60;visibleProcessedColumns&#x60; - bound from [visibleProcessedColumns](Components.ModelsTable.html#event_visibleProcessedColumns)
   * * &#x60;themeInstance&#x60; - bound from [themeInstance](Components.ModelsTable.html#property_themeInstance)
   * * &#x60;groupedItems&#x60; - list of all rows group items
   * * &#x60;visibleGroupedItems&#x60; - list of rows group items shown on the current table page
   * * &#x60;selectedGroupedItems&#x60; - list of selected rows group items
   * * &#x60;expandedGroupedItems&#x60; - list of expanded rows group items
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @groupingRowComponent={{component &quot;grouping-row&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @property groupingRowComponent
   * @type object
   * @default null
   */
  groupingRowComponent = null;

  /**
   * This component won&#x27;t be used if [useDataGrouping](Compnents.ModelsTable.html#property_useDataGrouping) is not &#x60;true&#x60;
   *
   * Component will receive several options:
   *
   * * &#x60;visibleProcessedColumns&#x60; - bound from [visibleProcessedColumns](Components.ModelsTable.html#property_visibleProcessedColumns)
   * * &#x60;themeInstance&#x60; - bound from [themeInstance](Components.ModelsTable.html#property_themeInstance)
   * * &#x60;groupedItems&#x60; - list of all rows group items
   * * &#x60;visibleGroupedItems&#x60; - list of rows group items shown on the current table page
   * * &#x60;selectedGroupedItems&#x60; - list of selected rows group items
   * * &#x60;expandedGroupedItems&#x60; - list of expanded rows group items
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @groupSummaryRowComponent={{component &quot;group-summary-row&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @property groupSummaryRowComponent
   * @type object
   * @default null
   */
  groupSummaryRowComponent = null;

  /**
   * Component for header cell for column with grouping value
   *
   * This component won&#x27;t be used if [useDataGrouping](Components.ModelsTable.html#property_useDataGrouping) is not &#x60;true&#x60; and [displayGroupedValueAs](Components.ModelsTable.html#property_displayGroupedValueAs) is not &#x60;columns&#x60;
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @groupHeaderCellComponent={{component &quot;group-header-cell&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * Component will receive such options:
   *
   * * &#x60;currentGroupingPropertyName&#x60; - property name used to group rows in the current moment
   *
   * @property groupHeaderCellComponent
   * @type object
   * @default null
   */
  groupHeaderCellComponent = null;

  /**
   * Closure action sent on user interaction
   *
   * Action will send one parameter - object with fields:
   *
   * * &#x60;sort&#x60; - list with sort value &#x60;propertyName:sortDirection&#x60;
   * * &#x60;currentPageNumber&#x60; - currently shown page number
   * * &#x60;pageSize&#x60; - current page size
   * * &#x60;filterString&#x60; - global filter value
   * * &#x60;filteredContent&#x60; - filtered data
   * * &#x60;selectedItems&#x60; - list with selected row items
   * * &#x60;expandedItems&#x60; - list with expanded row items
   * * &#x60;columnFilters&#x60; - hash with fields equal to filtered propertyName and values equal to filter values
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @displayDataChangedAction={{action &quot;someAction&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @event displayDataChangedAction
   */
  displayDataChangedAction = null;

  /**
   * Action sent on init to give access to the Public API
   *
   * @property registerAPI
   * @type Function
   * @default null
   */
  registerAPI = null;

  /**
   * Closure action sent on change of visible columns
   *
   * The action will receive an array of objects as parameter, where every object looks like this: &#x60;{ propertyName: &#x27;firstName&#x27;, isHidden: true, mayBeHidden: false }&#x60;
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @columnsVisibilityChangedAction={{action &quot;someAction&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @event columnsVisibilityChangedAction
   */
  columnsVisibilityChangedAction = null;

  /**
   * Closure action sent on row double-click
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @rowDoubleClickAction={{action &quot;someAction&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @event rowDoubleClickAction
   */
  rowDoubleClickAction = null;

  /**
   * Closure action sent on row hover
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @rowHoverAction={{action &quot;someAction&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @event rowHoverAction
   */
  rowHoverAction = null;

  /**
   * Closure action sent on row out
   *
   * @example
   * &#x60;&#x60;&#x60;hbs
   * &lt;ModelsTable
   *   @data={{model}}
   *   @columns={{columns}}
   *   @rowOutAction={{action &quot;someAction&quot;}}
   * /&gt;
   * &#x60;&#x60;&#x60;
   *
   * @event rowOutAction
   */
  rowOutAction = null;

  /**
   * List of currently selected row items
   *
   * Row may be selected by clicking on it, if [selectRowOnClick](Components.ModelsTable.html#event_selectRowOnClick) is set to &#x60;true&#x60;
   *
   * @property selectedItems
   * @type object[]
   * @default []
   */
  @computed()
  get selectedItems() {
    return A([]);
  }
  set selectedItems(v) {
    return A(v);
  }

  /**
   * List of the currently visible columns
   *
   * @protected
   * @property visibleProcessedColumns
   * @type object[]
   * @default []
   */
  @filterBy(&#x27;processedColumns&#x27;, &#x27;isVisible&#x27;, true) visibleProcessedColumns;

  /**
   * True if all processedColumns are hidden by &#x60;isHidden&#x60;
   *
   * @protected
   * @property allColumnsAreHidden
   * @type boolean
   * @default false
   */
  @computed(&#x27;processedColumns.@each.isHidden&#x27;)
  get allColumnsAreHidden() {
    return this.processedColumns &amp;&amp; this.processedColumns.length &gt; 0 &amp;&amp; this.processedColumns.isEvery(&#x27;isHidden&#x27;, true);
  }

  /**
   * List of property names can be used for grouping
   *
   * It may be a list of strings of list of objects. In first case label and value in the select-box will be the same.
   * In the second case you must set &#x60;label&#x60; and &#x60;value&#x60; properties for each list item
   *
   * **IMPORTANT** It must contain [currentGroupingPropertyName](Components.ModelsTable.html#property_currentGroupingPropertyName)-value
   *
   * @property dataGroupProperties
   * @type string[]|object[]
   * @default []
   */
  dataGroupProperties = A([]);

  /**
   * @protected
   * @property dataGroupOptions
   * @type Internal.SelectOption[]
   * @default []
   */
  @computed(&#x27;dataGroupProperties.[]&#x27;)
  get dataGroupOptions() {
    return this.dataGroupProperties.map(value =&gt; {
      return &#x27;object&#x27; === typeOf(value) || &#x27;instance&#x27; === typeOf(value) ? value : {
        label: propertyNameToTitle(value),
        value
      };
    });
  }

  /**
   * &#x60;true&#x60; if some value is set to the global filter
   *
   * @protected
   * @property globalFilterUsed
   * @type boolean
   * @default false
   */
  @notEmpty(&#x27;filterString&#x27;) globalFilterUsed;

  /**
   * &#x60;true&#x60; if global filter or filter by any column is used
   *
   * @protected
   * @property anyFilterUsed
   * @type boolean
   * @default false
   */
  @computed(&#x27;globalFilterUsed&#x27;, &#x27;processedColumns.@each.filterUsed&#x27;)
  get anyFilterUsed() {
    return this.globalFilterUsed || this.processedColumns.isAny(&#x27;filterUsed&#x27;);
  }

  /**
   * &#x60;true&#x60; if all processedColumns don&#x27;t use filtering and sorting
   *
   * @protected
   * @property noHeaderFilteringAndSorting
   * @type boolean
   * @default false
   */
  @computed(&#x27;processedColumns.@each.{useSorting,useFilter}&#x27;)
  get noHeaderFilteringAndSorting() {
    return this.processedColumns.isEvery(&#x27;useFilter&#x27;, false) &amp;&amp; this.processedColumns.isEvery(&#x27;useSorting&#x27;, false);
  }

  /**
   * Number of pages
   *
   * @protected
   * @property pagesCount
   * @type number
   * @default 0
   */
  @computed(&#x27;arrangedContent.[]&#x27;, &#x27;pageSize&#x27;)
  get pagesCount() {
    const pagesCount = get(this, &#x27;arrangedContent.length&#x27;) / this.pageSize;
    return (0 === pagesCount % 1) ? pagesCount : (Math.floor(pagesCount) + 1);
  }

  /**
   * [data](Components.ModelsTable.html#property_data) filtered with a global filter and columns filters
   *
   * Filtering by columns is ignored if [useFilteringByColumns](Components.ModelsTable.html#property_useFilteringByColumns) is set to &#x60;false&#x60;
   *
   * @protected
   * @property filteredContent
   * @type object[]
   * @default []
   */
  @computed(&#x27;filterString&#x27;, &#x27;data.[]&#x27;, &#x27;useFilteringByColumns&#x27;, &#x27;processedColumns.@each.filterString&#x27;)
  get filteredContent() {
    const {processedColumns, data, filteringIgnoreCase} = this;
    if (!isArray(data)) {
      return [];
    }
    if (!this.anyFilterUsed) {
      return data.slice();
    }
    let filterString = this.filterString;
    if (filteringIgnoreCase) {
      filterString = filterString.toLowerCase();
    }

    let _processedColumns = A(processedColumns.filterBy(&#x27;useFilter&#x27;));
    if (!this.doFilteringByHiddenColumns) {
      _processedColumns = A(_processedColumns.filterBy(&#x27;isHidden&#x27;, false));
    }
    if (!get(_processedColumns, &#x27;length&#x27;)) {
      return data.slice();
    }

    // global search
    const filtersFor = A(A(_processedColumns.mapBy(&#x27;filterField&#x27;)).compact());
    let globalSearch = data.filter(row =&gt; {
      return filtersFor.any(filterFor =&gt; {
        let cellValue = &#x27;&#x27; + get(row, filterFor);
        if (filteringIgnoreCase) {
          cellValue = cellValue.toLowerCase();
        }
        return -1 !== cellValue.indexOf(filterString);
      });
    });

    if (!this.useFilteringByColumns) {
      return globalSearch;
    }

    // search by each column
    _processedColumns = _processedColumns.filterBy(&#x27;filterField&#x27;).filter(c =&gt; !((get(c, &#x27;filterWithSelect&#x27;) &amp;&amp; &#x27;&#x27; === get(c, &#x27;filterString&#x27;))));
    return globalSearch.filter(row =&gt; {
      return _processedColumns.every(c =&gt; {
        const filterFor = get(c, &#x27;filterField&#x27;);
        let cellValue = &#x27;&#x27; + get(row, filterFor);
        let filterString = get(c, &#x27;filterString&#x27;);
        if (filteringIgnoreCase) {
          cellValue = typeOf(cellValue) === &#x27;string&#x27; ? cellValue.toLowerCase() : cellValue;
          filterString = typeOf(filterString) === &#x27;string&#x27; ? filterString.toLowerCase() : filterString;
        }
        return &#x27;function&#x27; === typeOf(c.filterFunction) ? c.filterFunction(cellValue, filterString, row) : 0 === compare(cellValue, filterString);
      });
    });
  }

  set filteredContent(v) {
    return v;
  }

  /**
   * [filteredContent](Components.ModelsTable.html#property_filteredContent) sorted by needed properties
   *
   * @protected
   * @property arrangedContent
   * @type object[]
   * @default []
   */
  @computed(&#x27;filteredContent.[]&#x27;, &#x27;sortProperties.[]&#x27;, &#x27;sortFunctions.[]&#x27;)
  get arrangedContent() {
    let sortProperties = this.sortProperties.map(p =&gt; {
      let [prop, direction] = p.split(&#x27;:&#x27;);
      direction = direction || &#x27;asc&#x27;;

      return [prop, direction];
    });

    let _filteredContent = this.filteredContent.slice();
    return sortProperties.length ? _filteredContent.sort((row1, row2) =&gt; {
      for (let i = 0; i &lt; sortProperties.length; i++) {
        let [prop, direction] = sortProperties[i];
        let sortFunction = get(this, &#x60;sortFunctions.${prop}&#x60;) || betterCompare;
        let result = prop ? sortFunction(get(row1, prop), get(row2, prop)) : 0;
        if (result !== 0) {
          return (direction === &#x27;desc&#x27;) ? (-1 * result) : result;
        }
      }

      return 0;
    }) : _filteredContent;
  }
  set arrangedContent(v) {
    return v;
  }

  /**
   * @method filteredContentObserver
   * @protected
   */
  filteredContentObserver() {
    run.once(this, this.filteredContentObserverOnce);
  }

  /**
   * @method filteredContentObserverOnce
   * @protected
   */
  filteredContentObserverOnce() {
    this.updateState({recordsCount: this.get(&#x27;filteredContent.length&#x27;)});
  }

  /**
   * [filteredContent](Components.ModelsTable.html#property_filteredContent) grouped by [currentGroupingPropertyName](Components.ModelsTable.html#property_currentGroupingPropertyName) sorted by needed properties
   *
   * @protected
   * @property groupedArrangedContent
   * @type object[]
   * @default []
   */
  @computed(&#x27;filteredContent.[]&#x27;, &#x27;sortProperties.[]&#x27;, &#x27;sortFunctions.[]&#x27;, &#x27;useDataGrouping&#x27;, &#x27;currentGroupingPropertyName&#x27;, &#x27;sortByGroupedFieldDirection&#x27;)
  get groupedArrangedContent() {
    const {useDataGrouping, currentGroupingPropertyName, filteredContent, sortByGroupedFieldDirection} = this;
    let grouped = {};
    if (!useDataGrouping || !isArray(filteredContent)) {
      return grouped;
    }
    let sortProperties = this.sortProperties.map(p =&gt; {
      let [prop, direction] = p.split(&#x27;:&#x27;);
      direction = direction || &#x27;asc&#x27;;
      return [prop, direction];
    });

    grouped = chunkBy(filteredContent, currentGroupingPropertyName, sortByGroupedFieldDirection);

    grouped = grouped.map(group =&gt; {
      return sortProperties.length ? A(group.sort((row1, row2) =&gt; {
        for (let i = 0; i &lt; sortProperties.length; i++) {
          let [prop, direction] = sortProperties[i];
          let sortFunction = get(this, &#x60;sortFunctions.${prop}&#x60;) || betterCompare;
          let result = prop ? sortFunction(get(row1, prop), get(row2, prop)) : 0;
          if (result !== 0) {
            return (direction === &#x27;desc&#x27;) ? (-1 * result) : result;
          }
        }
        return 0;
      })) : group;
    });
    return grouped.reduce((result, group) =&gt; A([...result, ...group]), []);
  }

  /**
   * Content of the current table page
   *
   * [arrangedContent](Componens.ModelsTable.html#property_arrangedContent) sliced for currently shown page
   *
   * @protected
   * @property visibleContent
   * @type object[]
   * @default []
   */
  @computed(&#x27;arrangedContent.[]&#x27;, &#x27;pageSize&#x27;, &#x27;currentPageNumber&#x27;)
  get visibleContent() {
    const {arrangedContent, pageSize, currentPageNumber} = this;
    const startIndex = pageSize * (currentPageNumber - 1);
    if (arrangedContent.length &lt; pageSize) {
      return arrangedContent;
    }
    return arrangedContent.slice(startIndex, startIndex + pageSize);
  }

  /**
   * Content of the current table page when rows grouping is used
   *
   * [groupedVisibleContent](Components.ModelsTable.html#property_groupedVisibleContent) sliced for currently shown page
   *
   * @protected
   * @property groupedVisibleContent
   * @type object[]
   * @default []
   */
  @computed(&#x27;groupedArrangedContent&#x27;, &#x27;pageSize&#x27;, &#x27;currentPageNumber&#x27;, &#x27;useDataGrouping&#x27;, &#x27;currentGroupingPropertyName&#x27;)
  get groupedVisibleContent() {
    const {useDataGrouping, currentGroupingPropertyName, groupedArrangedContent, pageSize, currentPageNumber} = this;
    if (!useDataGrouping) {
      return [];
    }
    const startIndex = pageSize * (currentPageNumber - 1);
    return get(groupedArrangedContent, &#x27;length&#x27;) &lt; pageSize ?
      chunkBy(groupedArrangedContent, currentGroupingPropertyName) :
      chunkBy(groupedArrangedContent.slice(startIndex, startIndex + pageSize), currentGroupingPropertyName);
  }

  /**
   * List of grouped property values in order to show groups in the table
   *
   * @protected
   * @property groupedVisibleContentValuesOrder
   * @type object[]
   * @default []
   */
  @computed(&#x27;groupedVisibleContent.[]&#x27;, &#x27;currentGroupingPropertyName&#x27;)
  get groupedVisibleContentValuesOrder() {
    return this.groupedVisibleContent.map(group =&gt; get(group, &#x60;firstObject.${this.currentGroupingPropertyName}&#x60;));
  }

  /**
   * Is user on the last page
   *
   * @property isLastPage
   * @type boolean
   * @protected
   */
  @computed(&#x27;currentPageNumber&#x27;, &#x27;pagesCount&#x27;)
  get isLastPage() {
    return this.currentPageNumber &gt;= this.pagesCount;
  }

  /**
   * Alias to &#x60;arrangedContent.length&#x60;
   *
   * @protected
   * @property arrangedContentLength
   * @type number
   * @default 0
   */
  @alias(&#x27;arrangedContent.length&#x27;) arrangedContentLength;

  /**
   * Index of the first currently shown record
   *
   * @protected
   * @property firstIndex
   * @type number
   * @default 0
   */
  @computed(&#x27;arrangedContentLength&#x27;, &#x27;pageSize&#x27;, &#x27;currentPageNumber&#x27;)
  get firstIndex() {
    return 0 === this.arrangedContentLength ? 0 : this.pageSize * (this.currentPageNumber - 1) + 1;
  }

  /**
   * Index of the last currently shown record
   *
   * @protected
   * @property lastIndex
   * @type number
   * @default 10
   */
  @computed(&#x27;isLastPage&#x27;, &#x27;arrangedContentLength&#x27;, &#x27;currentPageNumber&#x27;, &#x27;pageSize&#x27;)
  get lastIndex() {
    return this.isLastPage ? this.arrangedContentLength : this.currentPageNumber * this.pageSize;
  }

  /**
   * List of possible [pageSize](Components.ModelsTable.html#property_pageSize) values. Used to change size of &#x60;visibleContent&#x60;
   *
   * @property pageSizeValues
   * @type number[]
   * @default [10, 25, 50]
   */
  pageSizeValues = A([10, 25, 50]);

  /**
   * List of options for pageSize-selectBox
   * It&#x27;s mapped from [pageSizeValues](Components.ModelsTable.html#property_pageSizeValues)
   * This value should not be set manually!
   *
   * @protected
   * @property pageSizeOptions
   * @type SelectOption[]
   * @default []
   */
  pageSizeOptions = A([]);

  /**
   * List of options for pageNumber-selectBox
   *
   * @protected
   * @property currentPageNumberOptions
   * @type SelectOption[]
   * @default []
   */
  @computed(&#x27;pagesCount&#x27;)
  get currentPageNumberOptions() {
    return Array.apply(null, {length: this.pagesCount}).map((v, i) =&gt; optionStrToObj(i + 1));
  }

  /**
   * These are options for the columns dropdown.
   * By default, the &#x27;Show All&#x27;, &#x27;Hide All&#x27; and &#x27;Restore Defaults&#x27; buttons are displayed.
   *
   * @protected
   * @property columnDropdownOptions
   * @type Internal.ColumnDropdownOptions
   */
  @computed(&#x27;columnSets.{label,showColumns,hideOtherColumns}&#x27;)
  get columnDropdownOptions() {
    return EmberObject.create({
      showAll: true,
      hideAll: true,
      restoreDefaults: true,
      columnSets: A(this.columnSets || [])
    });
  }

  /**
   * Public API that allows for programmatic interaction with the component
   *
   *  * &#x60;refilter()&#x60; - Invalidates the filteredContent property, causing the table to be re-filtered.
   *  * &#x60;recordsCount&#x60; - Size of the current arranged content
   *
   *  @property publicAPI
   *  @default null
   */
  publicAPI = null;

  /**
   * @method updateState
   * @param {object} changes
   * @return object
   * @protected
   */
  updateState(changes) {
    let newState = set(this, &#x27;publicAPI&#x27;, assign({}, this.publicAPI, changes));
    let registerAPI = this.registerAPI;
    if (registerAPI) {
      registerAPI(newState);
    }
    return newState;
  }

  /**
   * Show first page if for some reasons there is no content for current page, but table data exists
   *
   * @method visibleContentObserver
   * @protected
   */
  visibleContentObserver() {
    run.once(this, this.visibleContentObserverOnce);
  }

  /**
   * @method visibleContentObserverOnce
   * @protected
   */
  visibleContentObserverOnce() {
    const visibleContentLength = get(this, &#x27;visibleContent.length&#x27;);
    const dataLength = get(this, &#x27;data.length&#x27;);
    if (!visibleContentLength &amp;&amp; dataLength &amp;&amp; this.currentPageNumber !== 1) {
      set(this, &#x27;currentPageNumber&#x27;, 1);
    }
  }

  init() {
    super.init(...arguments);
    this.setup();
  }

  didReceiveAttrs() {
    this.updateColumns();
  }

  didInsertElement() {
    this.focus();
    super.didInsertElement(...arguments);
    if (this.checkTextTranslations) {
      this._checkColumnTitles();
    }
  }

  /**
   * @method _checkColumnTitles
   * @protected
   */
  _checkColumnTitles() {
    this.columns.forEach((c, index) =&gt; {
      warn(&#x60;#${this.elementId}. No title. Column #${index}. ${c.propertyName}&#x60;, !(!hasOwnProperty.call(c,&#x27;title&#x27;) &amp;&amp; c.propertyName), {id: &#x27;#emt-column-no-title&#x27;});
    });
  }

  /**
   * Component init
   *
   * Set visibility and filtering attributes for each column
   *
   * @method setup
   * @protected
   */
  setup() {
    this._setupSelectedRows();
    this._setupColumns();
    this._setupPageSizeOptions();

    if (this.columnsAreUpdateable) {
      assert(&#x27;&#x60;columnFieldsToCheckUpdate&#x60; should be an array of strings&#x27;, &#x27;array&#x27; === typeOf(this.columnFieldsToCheckUpdate));
      this.columnFieldsToCheckUpdate.forEach(propertyName =&gt; this.addObserver(&#x60;columns.@each.${propertyName}&#x60;, this, this._setupColumnsOnce));
    }
    this.addObserver(&#x27;visibleContent.length&#x27;, this, this.visibleContentObserver);
    this.addObserver(&#x27;filteredContent.length&#x27;, this, this.filteredContentObserver);

    set(this, &#x27;publicAPI&#x27;, {});

    this.updateState({
      recordsCount: this.get(&#x27;filteredContent.length&#x27;) || 0,
      refilter: this.refilter.bind(this)
    });
  }

  /**
   * @method refilter
   * @protected
   */
  refilter() {
    this.notifyPropertyChange(&#x27;filteredContent&#x27;);
  }

  /**
   * Recalculate processedColumns when the columns attr changes
   *
   * @method updateColumns
   * @protected
   */
  updateColumns() {
    if (this.columnsAreUpdateable) {
      this._setupColumns();
    }
  }

  /**
   * Focus on &#x27;Global filter&#x27; on component render
   *
   * @method focus
   * @protected
   */
  focus() {
    if (this.showGlobalFilter &amp;&amp; this.focusGlobalFilter) {
      this.element.querySelector(&#x27;.filterString&#x27;).focus();
    }
  }

  /**
   * Preselect table rows if &#x60;selectedItems&#x60; is provided
   *
   * &#x60;multipleSelected&#x60; may be set &#x60;true&#x60; if &#x60;selectedItems&#x60; has more than 1 item
   *
   * @method _setupSelectedRows
   * @protected
   */
  _setupSelectedRows() {
    if (isArray(this.selectedItems) &amp;&amp; this.selectedItems.length &gt; 1 &amp;&amp; !this.multipleSelected) {
      warn(&#x27;&#x60;multipleSelected&#x60; is set &#x60;true&#x60;, because you have provided multiple &#x60;selectedItems&#x60;.&#x27;, false, {id: &#x27;#emt-multipleSelected_autoset&#x27;});
      set(this, &#x27;multipleSelected&#x27;, true);
    }
  }

  /**
   * Wrapper for [_setupColumns](Components.ModelsTable.html#method__setupColumns) to call it only once when observer is fired
   *
   * @method _setupColumnsOnce
   * @protected
   */
  _setupColumnsOnce() {
    run.once(this, this._setupColumns);
  }

  /**
   * Generate hash for column-&#x60;extend&#x60;
   *
   * @method _createColumnInstance
   * @param {Utils.ModelsTableColumn} options
   * @protected
   */
  _createColumnInstance(options) {
    const {propertyName, filteredBy, disableFiltering, filterWithSelect} = options;
    const column = ModelsTableColumn.create();
    if (filterWithSelect &amp;&amp; (filteredBy || propertyName) &amp;&amp; !disableFiltering) {
      let predefinedFilterOptions = get(options, &#x27;predefinedFilterOptions&#x27;);
      let usePredefinedFilterOptions = &#x27;array&#x27; === typeOf(predefinedFilterOptions);
      if (usePredefinedFilterOptions &amp;&amp; get(predefinedFilterOptions, &#x27;length&#x27;)) {
        const types = A([&#x27;object&#x27;, &#x27;instance&#x27;]);
        const allObjects = A(predefinedFilterOptions)
          .every(option =&gt;
            types.includes(typeOf(option)) &amp;&amp;
            hasOwnProperty.call(option, &#x27;label&#x27;) &amp;&amp;
            hasOwnProperty.call(option, &#x27;value&#x27;));
        const allPrimitives = A(predefinedFilterOptions)
          .every(option =&gt;
            !types.includes(typeOf(option)));
        assert(&#x27;&#x60;predefinedFilterOptions&#x60; should be an array of objects or primitives and not mixed&#x27;, allObjects || allPrimitives);
        if (allPrimitives) {
          predefinedFilterOptions = predefinedFilterOptions.map(optionStrToObj);
        }
        if (&#x27;&#x27; !== predefinedFilterOptions[0].value) {
          predefinedFilterOptions = [{value: &#x27;&#x27;, label: &#x27;&#x27;}, ...predefinedFilterOptions];
        }
        column.filterOptions = usePredefinedFilterOptions ? A(predefinedFilterOptions) : [];
        return column;
      }
      if (usePredefinedFilterOptions) {
        // Empty array as predefined filter
        column.disableFiltering = true;
        return column;
      }
      if (!!filteredBy || !!propertyName) {
        class C extends ModelsTableColumn {
          @getFilterOptionsCP(filteredBy || propertyName)
          filterOptions;
        }
        return C.create();
      }
    }
    return column;
  }

  /**
   * Set values for some column-properties after its creation
   *
   * @method _postProcessColumn
   * @param {Utils.ModelsTableColumn} column
   * @return Utils.ModelsTableColumn
   * @protected
   */
  _postProcessColumn(column) {
    set(column, &#x27;__mt&#x27;, this);
    const filterOptions = get(column, &#x27;filterOptions&#x27;);
    const placeholder = get(column, &#x27;filterPlaceholder&#x27;);
    if (isArray(filterOptions) &amp;&amp; placeholder &amp;&amp; !filterOptions[0].label) {
      set(column, &#x27;filterOptions.firstObject.label&#x27;, placeholder);
    }
    return column;
  }

  /**
   * Create a column.
   * This can be overwritten if you need to use your own column object.
   *
   * Override must something like:
   *
   * @example
   * &#x60;&#x60;&#x60;js
   * _createColumn(options) {
   *   const column = this._createColumnInstance(options);
   *   setProperties(column, options);
   *   return this._postProcessColumn(column);
   * }
   * &#x60;&#x60;&#x60;
   *
   * @param {Utils.ModelsTableColumn} options
   * @method _createColumn
   * @return {Utils.ModelsTableColumn}
   */
  _createColumn(options) {
    const column = this._createColumnInstance(options);
    setProperties(column, options);
    return this._postProcessColumn(column);
  }

  /**
   * Create new properties for &#x60;columns&#x60;
   *
   * @private
   * @method _setupColumns
   */
  _setupColumns() {
    let self = this;

    let nColumns = A(this.columns.map(column =&gt; {
      let filterFunction = get(column, &#x27;filterFunction&#x27;);
      filterFunction = &#x27;function&#x27; === typeOf(filterFunction) ? filterFunction : defaultFilter;

      let c = this._createColumn(column);

      [&#x27;colspanForSortCell&#x27;, &#x27;colspanForFilterCell&#x27;].forEach(prop =&gt; {
        const val = get(c, prop);
        assert(&#x60;&quot;${prop}&quot; must be 1 or greater. You passed &quot;${val}&quot;&#x60;, typeOf(val) === &#x27;number&#x27; &amp;&amp; val &gt;= 1);
      });

      setProperties(c, {
        filterString: get(c, &#x27;filterString&#x27;) || &#x27;&#x27;,
        originalDefinition: column
      });

      this._setupColumnsComponent(c, column);

      set(c, &#x27;filterFunction&#x27;, filterFunction);

      if (isNone(get(c, &#x27;mayBeHidden&#x27;))) {
        set(c, &#x27;mayBeHidden&#x27;, true);
      }

      const {sortDirection, sortPrecedence} = column;
      const hasSortPrecedence = !isNone(sortPrecedence) &amp;&amp; sortPrecedence &gt; NOT_SORTED;
      const defaultSortPrecedence = hasSortPrecedence ? sortPrecedence : NOT_SORTED;
      const defaultSorting = sortDirection &amp;&amp; (sortPrecedence &gt; NOT_SORTED) ? sortDirection.toLowerCase() : &#x27;none&#x27;;

      setProperties(c, {
        defaultVisible: !get(c, &#x27;isHidden&#x27;),
        sorting: defaultSorting,
        sortPrecedence: defaultSortPrecedence
      });
      return c;
    }));
    nColumns.filterBy(&#x27;propertyName&#x27;).forEach(column =&gt; {
      let propertyName = get(column, &#x27;propertyName&#x27;);
      if (isNone(get(column, &#x27;title&#x27;))) {
        set(column, &#x27;title&#x27;, propertyNameToTitle(propertyName));
      }
    });
    set(this, &#x27;processedColumns&#x27;, nColumns);

    set(this, &#x27;sortProperties&#x27;, A());
    const filteredOrderedColumns = nColumns.sortBy(&#x27;sortPrecedence&#x27;).filter(col =&gt; isSortedByDefault(col));
    filteredOrderedColumns.forEach(column =&gt; {
      self.send(&#x27;sort&#x27;, column);
      const defaultSortedBy = column.sortedBy || column.propertyName;
      let sortingArgs = [column, defaultSortedBy, column.sortDirection.toLowerCase()];
      if (this.multipleColumnsSorting) {
        this._multiColumnsSorting(...sortingArgs);
      }
      else {
        this._singleColumnSorting(...sortingArgs);
      }
    });
    this.updateHeaderCellsColspanOnce();
  }

  /**
   * Create new properties for &#x60;columns&#x60; for components
   *
   * @protected
   * @method _setupColumnsComponent
   */
  _setupColumnsComponent(c, column) {
    if (isPresent(this.columnComponents)) {

      // display component
      let componentName = get(column, &#x27;component&#x27;);
      if (isPresent(componentName)) {
        let hashComponent = get(this.columnComponents, componentName);
        if (isPresent(hashComponent)) {
          set(c, &#x27;component&#x27;, hashComponent);
        }
      }

      // edit component
      componentName = get(column, &#x27;componentForEdit&#x27;);
      if (isPresent(componentName)) {
        let hashComponent = get(this.columnComponents, componentName);
        if (isPresent(hashComponent)) {
          set(c, &#x27;componentForEdit&#x27;, hashComponent);
        }
      }

    }
  }

  /**
   * Provide backward compatibility with &#x60;pageSizeValues&#x60; equal to an array with numbers and not objects
   * &#x60;pageSizeValues&#x60; is live as is, &#x60;pageSizeOptions&#x60; is used in the templates
   *
   * @protected
   * @method _setupPageSizeOptions
   */
  _setupPageSizeOptions() {
    let pageSizeOptions = this.pageSizeValues.map(optionStrToObj);
    set(this, &#x27;pageSizeOptions&#x27;, pageSizeOptions);
  }

  /**
   * Set &#x60;sortProperties&#x60; when single-column sorting is used
   *
   * @protected
   * @method _singleColumnSorting
   */
  _singleColumnSorting(column, sortedBy, newSorting) {
    this.processedColumns.setEach(&#x27;sorting&#x27;, &#x27;none&#x27;);
    set(column, &#x27;sorting&#x27;, newSorting);
    let sortFunctions = Object.create(null);
    sortFunctions[sortedBy] = get(column, &#x27;sortFunction&#x27;);
    set(this, &#x27;sortFunctions&#x27;, sortFunctions);
    set(this, &#x27;sortProperties&#x27;, &#x27;none&#x27; === newSorting ? [] : [&#x60;${sortedBy}:${newSorting}&#x60;]);
  }

  /**
   * Set &#x60;sortProperties&#x60; when multi-columns sorting is used
   *
   * @method _multiColumnsSorting
   * @protected
   */
  _multiColumnsSorting(column, sortedBy, newSorting) {
    set(column, &#x27;sorting&#x27;, newSorting);
    let sortPropertiesMap = {};
    this.sortProperties.forEach(p =&gt; {
      let [propertyName, order] = p.split(&#x27;:&#x27;);
      sortPropertiesMap[propertyName] = order;
    });
    delete sortPropertiesMap[sortedBy];

    let newSortProperties = A([]);
    let newSortFunctions = Object.create(null);
    keys(sortPropertiesMap).forEach(propertyName =&gt; {
      if (propertyName !== sortedBy) {
        newSortProperties.pushObject(&#x60;${propertyName}:${sortPropertiesMap[propertyName]}&#x60;);
      }
      set(newSortFunctions, propertyName, get(column, &#x27;sortFunction&#x27;));
    });
    if (&#x27;none&#x27; !== newSorting) {
      newSortProperties.pushObject(&#x60;${sortedBy}:${newSorting}&#x60;);
      newSortFunctions[sortedBy] = get(column, &#x27;sortFunction&#x27;);
    }
    set(this, &#x27;sortProperties&#x27;, newSortProperties);
    set(this, &#x27;sortFunctions&#x27;, newSortFunctions);
  }

  /**
   * Send &#x60;displayDataChangedAction&#x60;-action when user does sort of filter.
   * Action is sent if &#x60;displayDataChangedAction&#x60; is a closure-action
   *
   * @protected
   * @method userInteractionObserver
   */
  userInteractionObserver() {
    run.once(this, this.userInteractionObserverOnce);
  }

  /**
   * @protected
   * @method userInteractionObserverOnce
   */
  userInteractionObserverOnce() {
    let actionIsFunction = typeof this.displayDataChangedAction === &#x27;function&#x27;;

    if (actionIsFunction) {
      let settings = EmberObject.create({
        sort: this.sortProperties,
        currentPageNumber: this.currentPageNumber,
        pageSize: this.pageSize,
        filterString: this.filterString,
        filteredContent: this.filteredContent,
        selectedItems: this.selectedItems,
        expandedItems: this.expandedItems,
        columns: this.processedColumns.map(c =&gt; getProperties(c, [&#x27;filterString&#x27;, &#x27;filterField&#x27;, &#x27;sortField&#x27;, &#x27;sorting&#x27;, &#x27;propertyName&#x27;])),
        columnFilters: {}
      });
      this.processedColumns.forEach(column =&gt; {
        if (!isBlank(get(column, &#x27;filterString&#x27;))) {
          settings.columnFilters[get(column, &#x27;propertyName&#x27;)] = get(column, &#x27;filterString&#x27;);
        }
      });
      this.displayDataChangedAction(settings);
    }
  }

  /**
   * Send &#x60;columnsVisibilityChangedAction&#x60;-action when user changes which columns are visible.
   * Action is sent if &#x60;columnsVisibilityChangedAction&#x60; is a closure action
   *
   * @protected
   * @method _sendColumnsVisibilityChangedAction
   */
  _sendColumnsVisibilityChangedAction() {
    let actionIsFunction = typeof this.columnsVisibilityChangedAction === &#x27;function&#x27;;

    if (actionIsFunction) {
      const columnsVisibility = this.processedColumns.map(column =&gt; {
        const options = getProperties(column, &#x27;isHidden&#x27;, &#x27;mayBeHidden&#x27;, &#x27;propertyName&#x27;);
        options.isHidden = !!options.isHidden;
        return options;
      });
      this.columnsVisibilityChangedAction(columnsVisibility);
    }
  }

  /**
   * Handler for global filter and filter by each column
   *
   * @protected
   * @method forceToFirstPage
   */
  forceToFirstPage() {
    set(this, &#x27;currentPageNumber&#x27;, 1);
    this.userInteractionObserver();
  }

  /**
   * Collapse open rows when user change page size or moved to the another page
   *
   * @protected
   * @method collapseRowOnNavigate
   */
  @observes(&#x27;currentPageNumber&#x27;, &#x27;pageSize&#x27;)
  collapseRowOnNavigate() {
    this.expandedItems.clear();
  }

  /**
   * Rebuild the whole table.
   * This can be called to force a complete re-render of the table.
   *
   * @method rebuildTable
   * @protected
   */
  rebuildTable() {
    set(this, &#x27;currentPageNumber&#x27;, 1);
    this._clearFilters();
    this.setup();
  }

  /**
   * Update colspans for table header cells
   *
   * @protected
   * @method updateHeaderCellsColspan
   */
  @observes(&#x27;processedColumns.@each.{isVisible,colspanForSortCell,colspanForFilterCell}&#x27;)
  updateHeaderCellsColspan() {
    run.once(this, this.updateHeaderCellsColspanOnce);
  }

  /**
   * @protected
   * @method updateHeaderCellsColspanOnce
   */
  updateHeaderCellsColspanOnce() {
    this.processedColumns.forEach((column, index, columns) =&gt; {
      const colspanForSortCell = get(column, &#x27;colspanForSortCell&#x27;);
      const colspanForFilterCell = get(column, &#x27;colspanForFilterCell&#x27;);
      const nextColumnsForSortCell = columns.slice(index, index + colspanForSortCell).filter(c =&gt; get(c, &#x27;isHidden&#x27;));
      const nextColumnsForFilterCell = columns.slice(index, index + colspanForFilterCell).filter(c =&gt; get(c, &#x27;isHidden&#x27;));
      set(column, &#x27;realColspanForSortCell&#x27;, colspanForSortCell - get(nextColumnsForSortCell, &#x27;length&#x27;));
      set(column, &#x27;realColspanForFilterCell&#x27;, colspanForFilterCell - get(nextColumnsForFilterCell, &#x27;length&#x27;));
    });
  }

  /**
   * Clear all filters.
   *
   * @protected
   * @method _clearFilters
   */
  _clearFilters() {
    set(this, &#x27;filterString&#x27;, &#x27;&#x27;);
    this.processedColumns.setEach(&#x27;filterString&#x27;, &#x27;&#x27;);
  }

  willInsertElement() {
    this.forceToFirstPageProps.forEach(propertyName =&gt; this.addObserver(propertyName, this, &#x27;forceToFirstPage&#x27;));
    return super.willInsertElement(...arguments);
  }

  willDestroyElement() {
    this.forceToFirstPageProps.forEach(propertyName =&gt; this.removeObserver(propertyName, this, &#x27;forceToFirstPage&#x27;));
    if (this.registerAPI) {
      this.registerAPI(null);
    }
    this.processedColumns.invoke(&#x27;destroy&#x27;);
    return super.willDestroyElement(...arguments);
  }

  /**
   * Toggle visibility for provided column
   *
   * It doesn&#x27;t do nothing if column can&#x27;t be hidden (see [mayBeHidden](Utils.ModelsTableColumn.html#property_mayBeHidden)). May trigger sending [columnsVisibilityChangedAction](Components.ModelsTable.html#event_columnsVisibilityChangedAction)
   *
   * @event toggleHidden
   * @param {Utils.ModelsTableColumn} column
   * @protected
   */
  @action
  toggleHidden(column) {
    if (get(column, &#x27;mayBeHidden&#x27;)) {
      column.toggleProperty(&#x27;isHidden&#x27;);
      this._sendColumnsVisibilityChangedAction();
    }
  }

  /**
   * Show all columns
   *
   * Set each column &#x60;isHidden&#x60; value to &#x60;false&#x60;. May trigger sending [columnsVisibilityChangedAction](Components.ModelsTable.html#event_columnsVisibilityChangedAction)
   *
   * @event showAllColumns
   * @protected
   */
  @action
  showAllColumns() {
    this.processedColumns.setEach(&#x27;isHidden&#x27;, false);
    this._sendColumnsVisibilityChangedAction();
  }

  /**
   * Hide all columns that may be hidden (see [mayBeHidden](Utils.ModelsTableColumn.html#property_mayBeHidden))
   *
   * May trigger sending [columnsVisibilityChangedAction](Components.ModelsTable.html#event_columnsVisibilityChangedAction)
   *
   * @event hideAllColumns
   * @protected
   */
  @action
  hideAllColumns() {
    A(this.processedColumns.filterBy(&#x27;mayBeHidden&#x27;)).setEach(&#x27;isHidden&#x27;, true);
    this._sendColumnsVisibilityChangedAction();
  }

  /**
   * Restore columns visibility values according to their default visibility settings (see [defaultVisible](Utils.ModelsTableColumn.html#property_defaultVisible))
   *
   * May trigger sending [columnsVisibilityChangedAction](Components.MdoelsTableColumn.html#event_columnsVisibilityChangedAction)
   *
   * @event restoreDefaultVisibility
   * @protected
   */
  @action
  restoreDefaultVisibility() {
    this.processedColumns.forEach(c =&gt; {
      set(c, &#x27;isHidden&#x27;, !get(c, &#x27;defaultVisible&#x27;));
      this._sendColumnsVisibilityChangedAction();
    });
  }

  /**
   * Toggle visibility for every column in the selected columns set
   *
   * It ignore columns that can&#x27;t be hidden (see [mayBeHidden](Utils.ModelsTableColumn.html#property_mayBeHidden)). May trigger sending [columnsVisibilityChangedAction](Components.ModelsTable.html#event_columnsVisibilityChangedAction)
   *
   * @event toggleColumnSet
   * @param {Internal.ColumnSet} columnSetToToggle
   * @protected
   */
  @action
  toggleColumnSet({showColumns = [], hideOtherColumns, toggleSet = false} = {}) {
    // If hideOtherColumns is not set, default to true if toggleSet=false, else to false
    hideOtherColumns = isNone(hideOtherColumns) ? !toggleSet : hideOtherColumns;

    // If showColumns is a function, call it
    if (typeOf(showColumns) === &#x27;function&#x27;) {
      return run(this, showColumns, this.processedColumns);
    }

    let setColumns = A([]);
    let otherColumns = A([]);

    this.processedColumns.forEach((column) =&gt; {
      let columnId = get(column, &#x27;propertyName&#x27;);

      if (!columnId || !get(column, &#x27;mayBeHidden&#x27;)) {
        return;
      }

      showColumns = A(showColumns);
      if (showColumns.includes(columnId)) {
        setColumns.pushObject(column);
      } else {
        otherColumns.pushObject(column);
      }
    });

    // By default, all columns should always be set to visible
    // However, if &#x60;toggleSet=true&#x60;, then the set should be toggled between visible/hidden
    // In this case, if one of the set columns is hidden, make them all visible, else hide them
    let targetVisibility = true;
    if (toggleSet) {
      targetVisibility = !!setColumns.findBy(&#x27;isVisible&#x27;, false);
    }

    setColumns.forEach((column) =&gt; {
      let columnId = get(column, &#x27;propertyName&#x27;);
      if (showColumns.includes(columnId) &amp;&amp; get(column, &#x27;isVisible&#x27;) !== targetVisibility) {
        this.send(&#x27;toggleHidden&#x27;, column);
      }
    });

    if (hideOtherColumns) {
      otherColumns.forEach((column) =&gt; {
        let columnId = get(column, &#x27;propertyName&#x27;);

        if (!showColumns.includes(columnId) &amp;&amp; get(column, &#x27;isVisible&#x27;)) {
          this.send(&#x27;toggleHidden&#x27;, column);
        }
      });
    }
  }

  /**
   * Pagination click-handler
   *
   * It moves user to the selected page. Check [models-table/pagination-numeric](Components.ModelsTablePaginationNumeric.html) and [models-table/pagination-simple](Components.ModelsTablePaginationSimple.html) for usage examples. May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event gotoCustomPage
   * @param {number} pageNumber
   * @protected
   */
  @action
  gotoCustomPage(pageNumber) {
    set(this, &#x27;currentPageNumber&#x27;, pageNumber);
    this.userInteractionObserver();
  }

  /**
   * Sort selected column by [sortedBy](Utils.ModelsTableColumn.html#property_sortedBy) or [propertyName](Utils.ModelsTableColumn.html#property_propertyName)
   *
   * It will drop sorting for other columns if [multipleColumnsSorting](Components.ModelsTable.html#property_multipleColumnsSorting) is set to &#x60;false&#x60;. It will add new sorting if [multipleColumnsSorting](Components.ModelsTable.html#property_multipleColumnsSorting) is set to &#x60;true&#x60;. May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction). Table will be dropped to the first page if sorting is done
   *
   * For multiColumns-sorting calling sort will change sort-order. E.g.:
   *
   * @example
   * &#x60;&#x60;&#x60;js
   * sortProperties = [&#x27;a:asc&#x27;, &#x27;b:asc&#x27;, &#x27;c:desc&#x27;];
   * sort({propertyName: &#x27;b&#x27;}); // sortProperties now is [&#x27;a:asc&#x27;, &#x27;c:desc&#x27;, &#x27;b:desc&#x27;]
   * &#x60;&#x60;&#x60;
   *
   * @event sort
   * @param {Utils.ModelsTableColumn} column
   * @protected
   */
  @action
  sort(column) {
    let sortedBy = get(column, &#x27;sortedBy&#x27;) || get(column, &#x27;propertyName&#x27;);
    if (!sortedBy) {
      return;
    }
    let currentSorting = get(column, &#x27;sorting&#x27;) || &#x27;none&#x27;;
    let newSorting = this.sortMap[currentSorting.toLowerCase()];
    if (sortedBy === this.currentGroupingPropertyName) {
      newSorting = this.sortByGroupedFieldDirection === &#x27;asc&#x27; ? &#x27;desc&#x27; : &#x27;asc&#x27;;
      set(this, &#x27;sortByGroupedFieldDirection&#x27;, newSorting);
      return;
    }
    let sortingArgs = [column, sortedBy, newSorting];
    if (this.multipleColumnsSorting) {
      this._multiColumnsSorting(...sortingArgs);
    }
    else {
      this._singleColumnSorting(...sortingArgs);
    }
    set(this, &#x27;currentPageNumber&#x27;, 1);
    this.userInteractionObserver();
  }

  /**
   * Expand selected row
   *
   * It will cause expandedRowComponent to be used for it. It will collapse already expanded row if [multipleExpand](Components.ModelsTable.html#property_multipleExpand) is set to &#x60;false&#x60;. Expanding is assigned to the record itself and not their index. So, if page #1 has first row expanded and user is moved to any another page, first row on new page won&#x27;t be expanded. But when user will be back to the first page, first row will be expanded. May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event expandRow
   * @param {number} index
   * @param {object} dataItem
   * @protected
   */
  @action
  expandRow(index, dataItem) {
    assert(&#x27;row index should be numeric&#x27;, typeOf(index) === &#x27;number&#x27;);
    const {multipleExpand, expandedItems} = this;
    if (!multipleExpand &amp;&amp; get(expandedItems, &#x27;length&#x27;) === 1) {
      expandedItems.clear();
    }
    expandedItems.pushObject(dataItem);
    this.userInteractionObserver();
  }

  /**
   * Collapse selected row
   *
   * May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event collapseRow
   * @param {number} index
   * @param {object} dataItem
   * @protected
   */
  @action
  collapseRow(index, dataItem) {
    assert(&#x27;row index should be numeric&#x27;, typeOf(index) === &#x27;number&#x27;);
    this.expandedItems.removeObject(dataItem);
    this.userInteractionObserver();
  }

  /**
   * Expand all rows in the current page
   *
   * It works only if [multipleExpand](Components.ModelsTable.html#property_multipleExpand) is set to &#x60;true&#x60;. May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event expandAllRows
   * @protected
   */
  @action
  expandAllRows() {
    const {multipleExpand, visibleContent} = this;
    if (multipleExpand) {
      if (this.useDataGrouping) {
        this.expandedItems.pushObjects(A(objToArray(this.groupedVisibleContent)));
      }
      else {
        this.expandedItems.pushObjects(A(visibleContent.slice()));
      }
      this.userInteractionObserver();
    }
  }

  /**
   * Collapse all rows in the current page
   *
   * May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event collapseAllRows
   * @protected
   */
  @action
  collapseAllRows() {
    this.expandedItems.clear();
    this.userInteractionObserver();
  }

  /**
   * Handler for row-click
   *
   * Toggle &#x60;selected&#x60;-state for row. Select only one or multiple rows depends on [multipleSelect](Components.ModelsTable.html#property_multipleSelect) value. May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event clickOnRow
   * @param {number} index
   * @param {object} dataItem
   * @protected
   */
  @action
  clickOnRow(index, dataItem) {
    assert(&#x27;row index should be numeric&#x27;, typeOf(index) === &#x27;number&#x27;);
    if (this.selectRowOnClick) {
      const {multipleSelect, selectedItems} = this;
      if (selectedItems.includes(dataItem)) {
        selectedItems.removeObject(dataItem);
      }
      else {
        if (!multipleSelect &amp;&amp; get(selectedItems, &#x27;length&#x27;) === 1) {
          selectedItems.clear();
        }
        selectedItems.pushObject(dataItem);
      }
    }
    this.userInteractionObserver();
  }

  /**
   * Handler for double-click on row
   *
   * May trigger sending [rowDoubleClickAction](Components.ModelsTable.html#event_rowDoubleClickAction)
   *
   * @event doubleClickOnRow
   * @param {number} index
   * @param {object} dataItem
   * @protected
   */
  @action
  doubleClickOnRow(index, dataItem) {
    assert(&#x27;row index should be numeric&#x27;, typeOf(index) === &#x27;number&#x27;);
    let actionIsFunction = typeof this.rowDoubleClickAction === &#x27;function&#x27;;
    if (actionIsFunction) {
      this.rowDoubleClickAction(index, dataItem);
    }
  }

  /**
   * Handler for row-hover
   *
   * May trigger sending [rowHoverAction](Components.ModelsTable.html#event_rowHoverAction)
   *
   * @event hoverOnRow
   * @param {number} index
   * @param {object} dataItem
   * @protected
   */
  @action
  hoverOnRow(index, dataItem) {
    assert(&#x27;row index should be numeric&#x27;, typeOf(index) === &#x27;number&#x27;);
    let actionIsFunction = typeof this.rowHoverAction === &#x27;function&#x27;;
    if (actionIsFunction) {
      this.rowHoverAction(index, dataItem);
    }
  }

  /**
   * Handler for row-hover
   *
   * May trigger sending [rowOutAction](Components.ModelsTable.html#event_rowOutAction)
   *
   * @event outRow
   * @param {number} index
   * @param {object} dataItem
   * @protected
   */
  @action
  outRow(index, dataItem) {
    assert(&#x27;row index should be numeric&#x27;, typeOf(index) === &#x27;number&#x27;);
    let actionIsFunction = typeof this.rowOutAction === &#x27;function&#x27;;
    if (actionIsFunction) {
      this.rowOutAction(index, dataItem);
    }
  }

  /**
   * Clear all column filters and global filter
   *
   * May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event clearFilters
   * @protected
   */
  @action
  clearFilters() {
    this._clearFilters();
  }

  /**
   * Select/deselect all rows
   *
   * May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event toggleAllSelection
   * @protected
   */
  @action
  toggleAllSelection() {
    const {selectedItems, data} = this;
    const allSelectedBefore = get(selectedItems, &#x27;length&#x27;) === get(data, &#x27;length&#x27;);
    selectedItems.clear();
    if (!allSelectedBefore) {
      const toSelect = data.slice ? data.slice() : data;
      selectedItems.pushObjects(toSelect);
    }
    this.userInteractionObserver();
  }

  /**
   * Expand or collapse all rows in the rows group
   *
   * **IMPORTANT** &#x60;multipleExpand&#x60; should be set to &#x60;true&#x60; otherwise this action won&#x27;t do anything
   *
   * @event toggleGroupedRowsExpands
   * @param {string|number|boolean} groupedValue
   * @protected
   */
  @action
  toggleGroupedRowsExpands(groupedValue) {
    if (!this.multipleExpand) {
      return;
    }
    const {expandedItems, currentGroupingPropertyName} = this;
    const groupedItems = this.groupedArrangedContent.filterBy(currentGroupingPropertyName, groupedValue);
    const notExpandedGroupItems = groupedItems.filter(record =&gt; expandedItems.indexOf(record) === -1);
    if (get(notExpandedGroupItems, &#x27;length&#x27;)) {
      const toPush = notExpandedGroupItems.filter(record =&gt; expandedItems.indexOf(record) === -1);
      expandedItems.pushObjects(toPush);
    }
    else {
      groupedItems.forEach(record =&gt; expandedItems.removeObject(record));
    }
    this.userInteractionObserver();
  }

  /**
   * Select/deselect rows from the rows group
   *
   * **IMPORTANT** &#x60;multipleSelect&#x60; should be set to &#x60;true&#x60; otherwise this action won&#x27;t do anything
   *
   * May trigger sending [displayDataChangedAction](Components.ModelsTable.html#event_displayDataChangedAction)
   *
   * @event toggleGroupedRowsSelection
   * @param {string|number|boolean} groupedValue
   * @protected
   */
  @action
  toggleGroupedRowsSelection(groupedValue) {
    if (!this.multipleSelect) {
      return;
    }
    const {selectedItems, currentGroupingPropertyName} = this;
    const groupedItems = this.groupedArrangedContent.filterBy(currentGroupingPropertyName, groupedValue);
    const notSelectedGroupItems = groupedItems.filter(record =&gt; selectedItems.indexOf(record) === -1);
    if (get(notSelectedGroupItems, &#x27;length&#x27;)) {
      const toPush = notSelectedGroupItems.filter(record =&gt; selectedItems.indexOf(record) === -1);
      selectedItems.pushObjects(toPush);
    }
    else {
      groupedItems.forEach(record =&gt; selectedItems.removeObject(record));
    }
    this.userInteractionObserver();
  }

  /**
   * Collapse or expand rows group
   *
   * @event toggleGroupedRows
   * @param {string|number|boolean} groupedValue
   * @protected
   */
  @action
  toggleGroupedRows(groupedValue) {
    if (this.collapsedGroupValues.includes(groupedValue)) {
      this.collapsedGroupValues.removeObject(groupedValue);
    }
    else {
      this.collapsedGroupValues.pushObject(groupedValue);
    }
  }

}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
